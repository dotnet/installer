From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Stephen Halter <halter73@gmail.com>
Date: Wed, 20 Jul 2022 09:32:56 -0700
Subject: [PATCH] Update SDK to 7.0.100-rc.1.22368.21 (#42803)

Backport: https://github.com/dotnet/aspnetcore/pull/42803

---
 global.json                                           |  4 ++--
 .../src/CodeFixRunner.cs                              |  3 ++-
 .../Analyzers/test/Verifiers/DiagnosticVerifier.cs    |  4 ++--
 .../WebAssembly/src/HotReload/HotReloadAgent.cs       | 11 +++++++++--
 src/Http/Headers/src/HeaderUtilities.cs               |  2 +-
 src/Http/Headers/src/SetCookieHeaderValue.cs          |  3 ++-
 src/Middleware/WebSockets/src/HandshakeHelpers.cs     |  4 ++--
 .../src/CompilationFailedExceptionFactory.cs          |  4 ++--
 src/Shared/ParameterBindingMethodCache.cs             |  1 +
 src/Testing/src/AssemblyTestLog.cs                    |  6 +++++-
 .../Components/test/Verifiers/DiagnosticVerifier.cs   |  4 ++--
 11 files changed, 30 insertions(+), 16 deletions(-)

diff --git a/global.json b/global.json
index d7a9a7f4a1..84ca052b3d 100644
--- a/global.json
+++ b/global.json
@@ -1,9 +1,9 @@
 {
   "sdk": {
-    "version": "7.0.100-preview.7.22361.1"
+    "version": "7.0.100-rc.1.22368.21"
   },
   "tools": {
-    "dotnet": "7.0.100-preview.7.22361.1",
+    "dotnet": "7.0.100-rc.1.22368.21",
     "runtimes": {
       "dotnet/x86": [
         "$(MicrosoftNETCoreBrowserDebugHostTransportVersion)"
diff --git a/src/Analyzers/Microsoft.AspNetCore.Analyzer.Testing/src/CodeFixRunner.cs b/src/Analyzers/Microsoft.AspNetCore.Analyzer.Testing/src/CodeFixRunner.cs
index 1b0493f4fe..7163503d7e 100644
--- a/src/Analyzers/Microsoft.AspNetCore.Analyzer.Testing/src/CodeFixRunner.cs
+++ b/src/Analyzers/Microsoft.AspNetCore.Analyzer.Testing/src/CodeFixRunner.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
@@ -52,7 +53,7 @@ public class CodeFixRunner
         {
             var message = string.Join(
                 Environment.NewLine,
-                diagnostics.Select(d => CSharpDiagnosticFormatter.Instance.Format(d)));
+                diagnostics.Select(d => CSharpDiagnosticFormatter.Instance.Format(d, CultureInfo.InvariantCulture)));
             throw new InvalidOperationException($"Compilation failed:{Environment.NewLine}{message}");
         }
     }
diff --git a/src/Components/Analyzers/test/Verifiers/DiagnosticVerifier.cs b/src/Components/Analyzers/test/Verifiers/DiagnosticVerifier.cs
index f020e0a221..8dde75a736 100644
--- a/src/Components/Analyzers/test/Verifiers/DiagnosticVerifier.cs
+++ b/src/Components/Analyzers/test/Verifiers/DiagnosticVerifier.cs
@@ -169,13 +169,13 @@ public abstract partial class DiagnosticVerifier
                         expected.Severity, actual.Severity, FormatDiagnostics(analyzer, actual)));
             }
 
-            if (actual.GetMessage() != expected.Message)
+            if (actual.GetMessage(CultureInfo.InvariantCulture) != expected.Message)
             {
                 Assert.True(false,
                     string.Format(
                         CultureInfo.InvariantCulture,
                         "Expected diagnostic message to be \"{0}\" was \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",
-                        expected.Message, actual.GetMessage(), FormatDiagnostics(analyzer, actual)));
+                        expected.Message, actual.GetMessage(CultureInfo.InvariantCulture), FormatDiagnostics(analyzer, actual)));
             }
         }
     }
diff --git a/src/Components/WebAssembly/WebAssembly/src/HotReload/HotReloadAgent.cs b/src/Components/WebAssembly/WebAssembly/src/HotReload/HotReloadAgent.cs
index eac34897a6..76606a3264 100644
--- a/src/Components/WebAssembly/WebAssembly/src/HotReload/HotReloadAgent.cs
+++ b/src/Components/WebAssembly/WebAssembly/src/HotReload/HotReloadAgent.cs
@@ -13,6 +13,9 @@ namespace Microsoft.Extensions.HotReload;
 
 internal sealed class HotReloadAgent : IDisposable
 {
+    /// Flags for hot reload handler Types like MVC's HotReloadService.
+    private const DynamicallyAccessedMemberTypes HotReloadHandlerLinkerFlags = DynamicallyAccessedMemberTypes.PublicMethods | DynamicallyAccessedMemberTypes.NonPublicMethods;
+
     private readonly Action<string> _log;
     private readonly AssemblyLoadEventHandler _assemblyLoad;
     private readonly ConcurrentDictionary<Guid, List<UpdateDelta>> _deltas = new();
@@ -49,6 +52,8 @@ internal sealed class HotReloadAgent : IDisposable
         public List<Action<Type[]?>> UpdateApplication { get; } = new();
     }
 
+    [UnconditionalSuppressMessage("Trimmer", "IL2072",
+        Justification = "The handlerType passed to GetHandlerActions is preserved by MetadataUpdateHandlerAttribute with DynamicallyAccessedMemberTypes.All.")]
     private UpdateHandlerActions GetMetadataUpdateHandlerActions()
     {
         // We need to execute MetadataUpdateHandlers in a well-defined order. For v1, the strategy that is used is to topologically
@@ -84,7 +89,9 @@ internal sealed class HotReloadAgent : IDisposable
         return handlerActions;
     }
 
-    internal void GetHandlerActions(UpdateHandlerActions handlerActions, Type handlerType)
+    internal void GetHandlerActions(
+        UpdateHandlerActions handlerActions,
+        [DynamicallyAccessedMembers(HotReloadHandlerLinkerFlags)] Type handlerType)
     {
         bool methodFound = false;
 
@@ -122,7 +129,7 @@ internal sealed class HotReloadAgent : IDisposable
             };
         }
 
-        MethodInfo? GetUpdateMethod(Type handlerType, string name)
+        MethodInfo? GetUpdateMethod([DynamicallyAccessedMembers(HotReloadHandlerLinkerFlags)] Type handlerType, string name)
         {
             if (handlerType.GetMethod(name, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static, new[] { typeof(Type[]) }) is MethodInfo updateMethod &&
                 updateMethod.ReturnType == typeof(void))
diff --git a/src/Http/Headers/src/HeaderUtilities.cs b/src/Http/Headers/src/HeaderUtilities.cs
index 1be3d47bc3..59e62d1b56 100644
--- a/src/Http/Headers/src/HeaderUtilities.cs
+++ b/src/Http/Headers/src/HeaderUtilities.cs
@@ -553,7 +553,7 @@ public static class HeaderUtilities
             return string.Create(31, dateTime, (span, dt) =>
             {
                 span[0] = span[30] = '"';
-                dt.TryFormat(span.Slice(1), out _, "r");
+                dt.TryFormat(span.Slice(1), out _, "r", CultureInfo.InvariantCulture);
             });
         }
 
diff --git a/src/Http/Headers/src/SetCookieHeaderValue.cs b/src/Http/Headers/src/SetCookieHeaderValue.cs
index 719e814179..d20dd90591 100644
--- a/src/Http/Headers/src/SetCookieHeaderValue.cs
+++ b/src/Http/Headers/src/SetCookieHeaderValue.cs
@@ -4,6 +4,7 @@
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.Diagnostics.Contracts;
+using System.Globalization;
 using System.Text;
 using Microsoft.Extensions.Primitives;
 
@@ -262,7 +263,7 @@ public class SetCookieHeaderValue
                 Append(ref span, ExpiresToken);
                 Append(ref span, EqualsToken);
 
-                var formatted = expiresValue.TryFormat(span, out var charsWritten, ExpiresDateFormat);
+                var formatted = expiresValue.TryFormat(span, out var charsWritten, ExpiresDateFormat, CultureInfo.InvariantCulture);
                 span = span.Slice(charsWritten);
 
                 Debug.Assert(formatted);
diff --git a/src/Middleware/WebSockets/src/HandshakeHelpers.cs b/src/Middleware/WebSockets/src/HandshakeHelpers.cs
index 3b69336fc1..e0047d2bcd 100644
--- a/src/Middleware/WebSockets/src/HandshakeHelpers.cs
+++ b/src/Middleware/WebSockets/src/HandshakeHelpers.cs
@@ -171,7 +171,7 @@ internal static class HandshakeHelpers
                 builder.Append('=');
                 var len = (parsedOptions.ClientMaxWindowBits > 9) ? 2 : 1;
                 var span = builder.AppendSpan(len);
-                var ret = parsedOptions.ClientMaxWindowBits.TryFormat(span, out var written);
+                var ret = parsedOptions.ClientMaxWindowBits.TryFormat(span, out var written, provider: CultureInfo.InvariantCulture);
                 Debug.Assert(ret);
                 Debug.Assert(written == len);
             }
@@ -266,7 +266,7 @@ internal static class HandshakeHelpers
             builder.Append('=');
             var len = (parsedOptions.ServerMaxWindowBits > 9) ? 2 : 1;
             var span = builder.AppendSpan(len);
-            var ret = parsedOptions.ServerMaxWindowBits.TryFormat(span, out var written);
+            var ret = parsedOptions.ServerMaxWindowBits.TryFormat(span, out var written, provider: CultureInfo.InvariantCulture);
             Debug.Assert(ret);
             Debug.Assert(written == len);
         }
diff --git a/src/Mvc/Mvc.Razor.RuntimeCompilation/src/CompilationFailedExceptionFactory.cs b/src/Mvc/Mvc.Razor.RuntimeCompilation/src/CompilationFailedExceptionFactory.cs
index e243ad4896..2a44958603 100644
--- a/src/Mvc/Mvc.Razor.RuntimeCompilation/src/CompilationFailedExceptionFactory.cs
+++ b/src/Mvc/Mvc.Razor.RuntimeCompilation/src/CompilationFailedExceptionFactory.cs
@@ -118,8 +118,8 @@ internal static class CompilationFailedExceptionFactory
     {
         var mappedLineSpan = diagnostic.Location.GetMappedLineSpan();
         return new DiagnosticMessage(
-            diagnostic.GetMessage(),
-            CSharpDiagnosticFormatter.Instance.Format(diagnostic),
+            diagnostic.GetMessage(CultureInfo.CurrentCulture),
+            CSharpDiagnosticFormatter.Instance.Format(diagnostic, CultureInfo.CurrentCulture),
             mappedLineSpan.Path,
             mappedLineSpan.StartLinePosition.Line + 1,
             mappedLineSpan.StartLinePosition.Character + 1,
diff --git a/src/Shared/ParameterBindingMethodCache.cs b/src/Shared/ParameterBindingMethodCache.cs
index ea236a9d98..55fa8c19ae 100644
--- a/src/Shared/ParameterBindingMethodCache.cs
+++ b/src/Shared/ParameterBindingMethodCache.cs
@@ -411,6 +411,7 @@ internal sealed class ParameterBindingMethodCache
         return TValue.BindAsync(httpContext, parameter);
     }
         
+    [RequiresUnreferencedCode("Performs reflection on type hierarchy. This cannot be statically analyzed.")]
     private MethodInfo? GetStaticMethodFromHierarchy(Type type, string name, Type[] parameterTypes, Func<MethodInfo, bool> validateReturnType)
     {
         bool IsMatch(MethodInfo? method) => method is not null && !method.IsAbstract && validateReturnType(method);
diff --git a/src/Testing/src/AssemblyTestLog.cs b/src/Testing/src/AssemblyTestLog.cs
index 231458991b..5475b6b905 100644
--- a/src/Testing/src/AssemblyTestLog.cs
+++ b/src/Testing/src/AssemblyTestLog.cs
@@ -286,7 +286,11 @@ public class AssemblyTestLog : IAcceptFailureReports, IDisposable
             .Enrich.FromLogContext()
             .Enrich.With(new AssemblyLogTimestampOffsetEnricher(logStart))
             .MinimumLevel.Verbose()
-            .WriteTo.File(fileName, outputTemplate: "[{TimestampOffset}] [{SourceContext}] [{Level}] {Message:l}{NewLine}{Exception}", flushToDiskInterval: TimeSpan.FromSeconds(1), shared: true)
+            .WriteTo.File(fileName,
+                outputTemplate: "[{TimestampOffset}] [{SourceContext}] [{Level}] {Message:l}{NewLine}{Exception}",
+                flushToDiskInterval: TimeSpan.FromSeconds(1),
+                shared: true,
+                formatProvider: CultureInfo.InvariantCulture)
             .CreateLogger();
 
         return new SerilogLoggerProvider(serilogger, dispose: true);
diff --git a/src/Tools/SDK-Analyzers/Components/test/Verifiers/DiagnosticVerifier.cs b/src/Tools/SDK-Analyzers/Components/test/Verifiers/DiagnosticVerifier.cs
index f020e0a221..8dde75a736 100644
--- a/src/Tools/SDK-Analyzers/Components/test/Verifiers/DiagnosticVerifier.cs
+++ b/src/Tools/SDK-Analyzers/Components/test/Verifiers/DiagnosticVerifier.cs
@@ -169,13 +169,13 @@ public abstract partial class DiagnosticVerifier
                         expected.Severity, actual.Severity, FormatDiagnostics(analyzer, actual)));
             }
 
-            if (actual.GetMessage() != expected.Message)
+            if (actual.GetMessage(CultureInfo.InvariantCulture) != expected.Message)
             {
                 Assert.True(false,
                     string.Format(
                         CultureInfo.InvariantCulture,
                         "Expected diagnostic message to be \"{0}\" was \"{1}\"\r\n\r\nDiagnostic:\r\n    {2}\r\n",
-                        expected.Message, actual.GetMessage(), FormatDiagnostics(analyzer, actual)));
+                        expected.Message, actual.GetMessage(CultureInfo.InvariantCulture), FormatDiagnostics(analyzer, actual)));
             }
         }
     }
