parameters:
- name: pipelineId
  type: string

- name: pullRequestTitle
  type: string
  default: Update Test Baselines 

- name: pullRequestTargetBranch
  type: string
  default: $(Build.SourceBranchName)

- name: testResultsPath
  type: string

steps:
  - script: |
      set -euo pipefail
      declare -g body="Updates baselines from pipeline ${{ parameters.pipelineId }} build [$(Build.BuildId)](https://dev.azure.com/dnceng/internal/_build/results?buildId=$(Build.BuildId)&view=results) (internal Microsoft link)."
      declare -g fork_repo
      declare -g target_repo
      declare -g target_branch
      declare -g new_branch_name

      function CheckParameters() {
        # Pipeline ID must be either the SDK diff tests pipeline ID or the license scan pipeline ID
        if [[ "${{ parameters.pipelineId }}" != "$(SOURCE_BUILD_SDK_DIFF_TESTS_PIPELINE_ID)" ]] && [[ "${{ parameters.pipelineId }}" != "$(SOURCE_BUILD_LICENSE_SCAN_PIPELINE_ID)" ]]; then
          echo "This template does not support pipeline ${{ parameters.pipelineId }}."
          exit 1
        fi

        if [[ ! -d "${{ parameters.testResultsPath }}" ]]; then
          echo "Test results path ${{ parameters.testResultsPath }} does not exist."
          exit 1
        fi
      }

      function ConfigureGitRepo() {
        time=$(date +%s)
        monthDayYear=$(date +"%m-%d-%y")

        gh auth setup-git

        fork_repo="dotnet/installer"
        target_repo="dotnet/installer"
        fork_url="https://github.com/${fork_repo}"
        target_url="https://github.com/${target_repo}"

        repo_dir="repo-${time}"
        git clone "${fork_url}" "${repo_dir}" --depth 1
        cd "${repo_dir}"
        git remote add upstream "${target_url}"

        target_branch=$(echo "${{ parameters.pullRequestTargetBranch }}" | sed 's/internal\///')
        git fetch upstream "${target_branch}"

        new_branch_name="${monthDayYear}-source-build-tests-${time}"
        git checkout -b "${new_branch_name}" "upstream/${target_branch}"

        git config --global user.name "dotnet-sb-bot"
        git config --global user.email "dotnet-sb-bot@microsoft.com"
      }

      function UnionExclusions() {
        original_test_file=$1
        shift
        updated_test_files="$@"

        cat $updated_test_files | sort | uniq > temp.txt
        awk 'NR==FNR { lines[$0] = 1; next } $0 in lines' temp.txt $original_test_file > temp2.txt && mv temp2.txt $original_test_file

        rm temp.txt

        git add $original_test_file
      }

      function IntersectionExclusions() {
        original_test_file=$1
        shift
        updated_test_files="$@"

        for file in $updated_test_files; do
          grep -F -x -f $file $original_test_file > temp.txt && mv temp.txt $original_test_file
        done

        git add $original_test_file
      }

      function CopyNewFilesAndUpdateGit() {
        destination_path=$1
        shift
        updated_files="$@"

        relative_path=$(realpath --relative-to="$(pwd)" "$destination_path")

        for updated_file in $updated_files; do
          original_filename=$(basename $updated_file | sed 's/Updated//g')
          touch $destination_path/$original_filename
          cp $updated_file $destination_path/$original_filename
          git add $destination_path/$original_filename

          body+=$'\n'
          body+=" - Could not find $original_filename in $relative_path."
          body+=" The updated file has been added in this PR."
          body+=$'\n'
        done
      }

      function CreateLicenseBaseline() {
        destination_path=$1
        updated_test_file=$2
        default_baseline_content=$'{\n  "files": []\n}'
        baseline_path="$destination_path/baselines/licenses"

        if [[ "$(cat $updated_test_file)" != $default_baseline_content ]]; then
          CopyNewFilesAndUpdateGit $baseline_path $updated_test_file
        fi
      }

      function MakePrChanges() {
        relative_target_path="src/SourceBuild/content/test/Microsoft.DotNet.SourceBuild.SmokeTests/assets"
        absolute_target_path=$(realpath $relative_target_path)
        declare -A files
        updated_test_files=$(find "${{ parameters.testResultsPath }}" -name "Updated*");

        for test_file in $updated_test_files; do
          filename=$(basename "$test_file" | sed 's/Updated//g' | sed 's/\..*$//')
          files["$filename"]+=" $test_file"
        done

        for filename in "${!files[@]}"; do
          updated_test_files="${files[$filename]}"

          if [[ $filename == *"Exclusions"* ]]; then
            # Exclusion files get combined.
            # There can only be one exclusion file per key, so we need to check for a file matching the key.

            original_test_file=$(find "$absolute_target_path" -name "${filename}.*")
            if [ -z "$original_test_file" ]; then
              CopyNewFilesAndUpdateGit $absolute_target_path $updated_test_files
            elif [[ "${{ parameters.pipelineId }}" == "$(SOURCE_BUILD_SDK_DIFF_TESTS_PIPELINE_ID)" ]]; then
              UnionExclusions $original_test_file $updated_test_files
            elif [[ "${{ parameters.pipelineId }}" == "$(SOURCE_BUILD_LICENSE_SCAN_PIPELINE_ID)" ]]; then
              IntersectionExclusions $original_test_file $updated_test_files
            else
              echo "Unsure of how to combine exclusions files for pipeline type. Exiting."
              exit 1
            fi
          else
            for updated_test_file in $updated_test_files; do
              # Non-exclusion files get copied over.
              # There can be multiple files per key, so we need to check for a file matching each updated file.

              original_test_filename=$(basename $updated_test_file | sed 's/Updated//g')
              original_test_filepath=$(find "$absolute_target_path" -name "$original_test_filename")
              if [ -z "$original_test_filepath" ]; then
                if [[ "${{ parameters.pipelineId }}" == "$(SOURCE_BUILD_LICENSE_SCAN_PIPELINE_ID)" ]]; then
                  CreateLicenseBaseline $absolute_target_path $updated_test_file
                else
                  CopyNewFilesAndUpdateGit $absolute_target_path $updated_test_file
                fi
              else
                cp $updated_test_file $original_test_filepath
                git add $original_test_filepath
              fi
            done
          fi
        done
      }

      function CreatePr() {
        if [[ -z $(git status --porcelain) ]]; then
          echo "No changes to commit. Exiting."
          exit 0
        fi

        git commit -m "Update test baselines from pipeline ${{ parameters.pipelineId }} build $(Build.BuildId)"
        git push -u origin "${new_branch_name}"

        readarray -d '/' -t fork_repo_split <<< "${fork_repo}"
        fork_owner="${fork_repo_split[0]}"

        title="${{ parameters.pullRequestTitle }}"

        echo "TargetRepo: $target_repo"
        echo "ForkRepo: $fork_repo"
        echo "Title: $title"
        echo "Body: $body"

        # create pull request
        gh pr create \
          --head "${fork_owner}:${new_branch_name}" \
          --repo "${target_repo}" \
          --base "${target_branch}" \
          --title "${title}" \
          --body "${body}"
      }

      CheckParameters
      ConfigureGitRepo
      MakePrChanges
      CreatePr
    displayName: Publish Test Results PR
    workingDirectory: $(Build.SourcesDirectory)
    condition: succeededOrFailed()
    env:
      GH_TOKEN: $(BotAccount-dotnet-sb-bot-pat)
