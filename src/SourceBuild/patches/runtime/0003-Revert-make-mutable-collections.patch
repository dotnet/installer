From 53447c2a60474bbe33d57cc155a67848f21db0f5 Mon Sep 17 00:00:00 2001
From: Viktor Hofer <viktor.hofer@microsoft.com>
Date: Thu, 2 May 2024 11:35:05 +0200
Subject: [PATCH] Reapply "Make mutable generic collection interfaces implement
 read-only collection interfaces (#95830)" (#101644)

This reverts commit b8fe1d0ccb60926d6e7ef5d42e2398c178c9ee5c.
---
 .../System/Diagnostics/DiagnosticsHelper.cs   |  8 +++++
 .../Frozen/FrozenSetInternalBase.cs           | 12 +++++++
 .../Immutable/ImmutableExtensions.Minimal.cs  |  2 ++
 .../Collections/Generic/PriorityQueue.cs      |  2 +-
 .../System/Collections/Generic/SortedSet.cs   |  2 +-
 .../src/System/Dynamic/ExpandoObject.cs       | 32 ++++++++++++++++++-
 .../src/System/Linq/ParallelEnumerable.cs     |  4 +--
 .../System.Linq/src/System/Linq/AnyAll.cs     |  2 +-
 .../src/System/Linq/AppendPrepend.SpeedOpt.cs |  4 +--
 .../System.Linq/src/System/Linq/Count.cs      |  4 +--
 .../System/Linq/DefaultIfEmpty.SpeedOpt.cs    |  2 +-
 .../System.Linq/src/System/Linq/ElementAt.cs  |  4 +--
 .../System.Linq/src/System/Linq/First.cs      |  2 +-
 .../System.Linq/src/System/Linq/Grouping.cs   | 17 +++++++++-
 .../System.Linq/src/System/Linq/Last.cs       |  4 +--
 .../System/Linq/OrderedEnumerable.SpeedOpt.cs |  2 +-
 .../src/System/Linq/Reverse.SpeedOpt.cs       |  6 ++--
 .../src/System/Linq/SequenceEqual.cs          |  4 +--
 .../System.Linq/src/System/Linq/Single.cs     |  2 +-
 .../ServiceNameCollection.cs                  |  2 +-
 .../Collections/Concurrent/ConcurrentQueue.cs |  2 +-
 .../System/Collections/Generic/Dictionary.cs  |  2 +-
 .../src/System/Collections/Generic/HashSet.cs | 12 +++----
 .../Xml/Xsl/Runtime/XmlQuerySequence.cs       | 17 ++++++++--
 .../src/System/Text/Json/Nodes/JsonObject.cs  |  7 +++-
 25 files changed, 121 insertions(+), 36 deletions(-)

diff --git a/src/libraries/Common/src/System/Diagnostics/DiagnosticsHelper.cs b/src/libraries/Common/src/System/Diagnostics/DiagnosticsHelper.cs
index ce7f345b0ea..dcc9de3e4ad 100644
--- a/src/libraries/Common/src/System/Diagnostics/DiagnosticsHelper.cs
+++ b/src/libraries/Common/src/System/Diagnostics/DiagnosticsHelper.cs
@@ -35,14 +35,22 @@ internal static bool CompareTags(List<KeyValuePair<string, object?>>? sortedTags
             int size = count / (sizeof(ulong) * 8) + 1;
             BitMapper bitMapper = new BitMapper(size <= 100 ? stackalloc ulong[size] : new ulong[size]);
 
+#if NET9_0_OR_GREATER // ICollection<T> : IReadOnlyCollection<T> on .NET 9+
+            if (tags2 is IReadOnlyCollection<KeyValuePair<string, object?>> tagsCol)
+#else
             if (tags2 is ICollection<KeyValuePair<string, object?>> tagsCol)
+#endif
             {
                 if (tagsCol.Count != count)
                 {
                     return false;
                 }
 
+#if NET9_0_OR_GREATER // IList<T> : IReadOnlyList<T> on .NET 9+
+                if (tagsCol is IReadOnlyList<KeyValuePair<string, object?>> secondList)
+#else
                 if (tagsCol is IList<KeyValuePair<string, object?>> secondList)
+#endif
                 {
                     for (int i = 0; i < count; i++)
                     {
diff --git a/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenSetInternalBase.cs b/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenSetInternalBase.cs
index 4afe1f7503e..02e5e0cc07c 100644
--- a/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenSetInternalBase.cs
+++ b/src/libraries/System.Collections.Immutable/src/System/Collections/Frozen/FrozenSetInternalBase.cs
@@ -32,7 +32,11 @@ private protected override bool IsProperSubsetOfCore(IEnumerable<T> other)
         {
             Debug.Assert(_thisSet.Count != 0, "EmptyFrozenSet should have been used.");
 
+#if NET9_0_OR_GREATER // ICollection<T> : IReadOnlyCollection<T> on .NET 9+
+            if (other is IReadOnlyCollection<T> otherAsCollection)
+#else
             if (other is ICollection<T> otherAsCollection)
+#endif
             {
                 int otherCount = otherAsCollection.Count;
 
@@ -59,7 +63,11 @@ private protected override bool IsProperSupersetOfCore(IEnumerable<T> other)
         {
             Debug.Assert(_thisSet.Count != 0, "EmptyFrozenSet should have been used.");
 
+#if NET9_0_OR_GREATER // ICollection<T> : IReadOnlyCollection<T> on .NET 9+
+            if (other is IReadOnlyCollection<T> otherAsCollection)
+#else
             if (other is ICollection<T> otherAsCollection)
+#endif
             {
                 int otherCount = otherAsCollection.Count;
 
@@ -103,7 +111,11 @@ private protected override bool IsSupersetOfCore(IEnumerable<T> other)
             Debug.Assert(_thisSet.Count != 0, "EmptyFrozenSet should have been used.");
 
             // Try to compute the answer based purely on counts.
+#if NET9_0_OR_GREATER // ICollection<T> : IReadOnlyCollection<T> on .NET 9+
+            if (other is IReadOnlyCollection<T> otherAsCollection)
+#else
             if (other is ICollection<T> otherAsCollection)
+#endif
             {
                 int otherCount = otherAsCollection.Count;
 
diff --git a/src/libraries/System.Collections.Immutable/src/System/Collections/Immutable/ImmutableExtensions.Minimal.cs b/src/libraries/System.Collections.Immutable/src/System/Collections/Immutable/ImmutableExtensions.Minimal.cs
index 66b365bad87..dc9c7d26898 100644
--- a/src/libraries/System.Collections.Immutable/src/System/Collections/Immutable/ImmutableExtensions.Minimal.cs
+++ b/src/libraries/System.Collections.Immutable/src/System/Collections/Immutable/ImmutableExtensions.Minimal.cs
@@ -38,11 +38,13 @@ internal static bool TryGetCount<T>(this IEnumerable sequence, out int count)
                 return true;
             }
 
+#if !NET9_0_OR_GREATER // ICollection<T> : IReadOnlyCollection<T> on .NET 9+
             if (sequence is ICollection<T> collectionOfT)
             {
                 count = collectionOfT.Count;
                 return true;
             }
+#endif
 
             if (sequence is IReadOnlyCollection<T> readOnlyCollection)
             {
diff --git a/src/libraries/System.Collections/src/System/Collections/Generic/PriorityQueue.cs b/src/libraries/System.Collections/src/System/Collections/Generic/PriorityQueue.cs
index 5047b764337..072e5ac34d6 100644
--- a/src/libraries/System.Collections/src/System/Collections/Generic/PriorityQueue.cs
+++ b/src/libraries/System.Collections/src/System/Collections/Generic/PriorityQueue.cs
@@ -462,7 +462,7 @@ public void EnqueueRange(IEnumerable<TElement> elements, TPriority priority)
             ArgumentNullException.ThrowIfNull(elements);
 
             int count;
-            if (elements is ICollection<TElement> collection &&
+            if (elements is IReadOnlyCollection<TElement> collection &&
                 (count = collection.Count) > _nodes.Length - _size)
             {
                 Grow(checked(_size + count));
diff --git a/src/libraries/System.Collections/src/System/Collections/Generic/SortedSet.cs b/src/libraries/System.Collections/src/System/Collections/Generic/SortedSet.cs
index 2f7406d0d7b..fd0beccb28a 100644
--- a/src/libraries/System.Collections/src/System/Collections/Generic/SortedSet.cs
+++ b/src/libraries/System.Collections/src/System/Collections/Generic/SortedSet.cs
@@ -1323,7 +1323,7 @@ public bool Overlaps(IEnumerable<T> other)
             if (Count == 0)
                 return false;
 
-            if (other is ICollection<T> c && c.Count == 0)
+            if (other is IReadOnlyCollection<T> c && c.Count == 0)
                 return false;
 
             SortedSet<T>? asSorted = other as SortedSet<T>;
diff --git a/src/libraries/System.Linq.Expressions/src/System/Dynamic/ExpandoObject.cs b/src/libraries/System.Linq.Expressions/src/System/Dynamic/ExpandoObject.cs
index 288d01c185d..906ee3fd84f 100644
--- a/src/libraries/System.Linq.Expressions/src/System/Dynamic/ExpandoObject.cs
+++ b/src/libraries/System.Linq.Expressions/src/System/Dynamic/ExpandoObject.cs
@@ -17,7 +17,7 @@ namespace System.Dynamic
     /// <summary>
     /// Represents an object with members that can be dynamically added and removed at runtime.
     /// </summary>
-    public sealed class ExpandoObject : IDynamicMetaObjectProvider, IDictionary<string, object?>, INotifyPropertyChanged
+    public sealed class ExpandoObject : IDynamicMetaObjectProvider, IDictionary<string, object?>, IReadOnlyDictionary<string, object?>, INotifyPropertyChanged
     {
         private static readonly MethodInfo s_expandoTryGetValue =
             typeof(RuntimeOps).GetMethod(nameof(RuntimeOps.ExpandoTryGetValue))!;
@@ -618,6 +618,10 @@ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
 
         ICollection<object?> IDictionary<string, object?>.Values => new ValueCollection(this);
 
+        IEnumerable<string> IReadOnlyDictionary<string, object?>.Keys => new KeyCollection(this);
+
+        IEnumerable<object?> IReadOnlyDictionary<string, object?>.Values => new ValueCollection(this);
+
         object? IDictionary<string, object?>.this[string key]
         {
             get
@@ -636,6 +640,18 @@ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
             }
         }
 
+        object? IReadOnlyDictionary<string, object?>.this[string key]
+        {
+            get
+            {
+                if (!TryGetValueForKey(key, out object? value))
+                {
+                    throw System.Linq.Expressions.Error.KeyDoesNotExistInExpando(key);
+                }
+                return value;
+            }
+        }
+
         void IDictionary<string, object?>.Add(string key, object? value)
         {
             this.TryAddMember(key, value);
@@ -650,6 +666,15 @@ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
             return index >= 0 && data[index] != Uninitialized;
         }
 
+        bool IReadOnlyDictionary<string, object?>.ContainsKey(string key)
+        {
+            ArgumentNullException.ThrowIfNull(key);
+
+            ExpandoData data = _data;
+            int index = data.Class.GetValueIndexCaseSensitive(key);
+            return index >= 0 && data[index] != Uninitialized;
+        }
+
         bool IDictionary<string, object?>.Remove(string key)
         {
             ArgumentNullException.ThrowIfNull(key);
@@ -662,6 +687,11 @@ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
             return TryGetValueForKey(key, out value);
         }
 
+        bool IReadOnlyDictionary<string, object?>.TryGetValue(string key, out object? value)
+        {
+            return TryGetValueForKey(key, out value);
+        }
+
         #endregion
 
         #region ICollection<KeyValuePair<string, object>> Members
diff --git a/src/libraries/System.Linq.Parallel/src/System/Linq/ParallelEnumerable.cs b/src/libraries/System.Linq.Parallel/src/System/Linq/ParallelEnumerable.cs
index 55ef371ea04..f0885d3d3e7 100644
--- a/src/libraries/System.Linq.Parallel/src/System/Linq/ParallelEnumerable.cs
+++ b/src/libraries/System.Linq.Parallel/src/System/Linq/ParallelEnumerable.cs
@@ -1852,7 +1852,7 @@ public static int Count<TSource>(this ParallelQuery<TSource> source)
             // If the data source is a collection, we can just return the count right away.
             if (source is ParallelEnumerableWrapper<TSource> sourceAsWrapper)
             {
-                if (sourceAsWrapper.WrappedEnumerable is ICollection<TSource> sourceAsCollection)
+                if (sourceAsWrapper.WrappedEnumerable is IReadOnlyCollection<TSource> sourceAsCollection)
                 {
                     return sourceAsCollection.Count;
                 }
@@ -1923,7 +1923,7 @@ public static long LongCount<TSource>(this ParallelQuery<TSource> source)
             // If the data source is a collection, we can just return the count right away.
             if (source is ParallelEnumerableWrapper<TSource> sourceAsWrapper)
             {
-                if (sourceAsWrapper.WrappedEnumerable is ICollection<TSource> sourceAsCollection)
+                if (sourceAsWrapper.WrappedEnumerable is IReadOnlyCollection<TSource> sourceAsCollection)
                 {
                     return sourceAsCollection.Count;
                 }
diff --git a/src/libraries/System.Linq/src/System/Linq/AnyAll.cs b/src/libraries/System.Linq/src/System/Linq/AnyAll.cs
index 28a3783aa88..d6d6e4adccd 100644
--- a/src/libraries/System.Linq/src/System/Linq/AnyAll.cs
+++ b/src/libraries/System.Linq/src/System/Linq/AnyAll.cs
@@ -15,7 +15,7 @@ public static bool Any<TSource>(this IEnumerable<TSource> source)
                 ThrowHelper.ThrowArgumentNullException(ExceptionArgument.source);
             }
 
-            if (source is ICollection<TSource> gc)
+            if (source is IReadOnlyCollection<TSource> gc)
             {
                 return gc.Count != 0;
             }
diff --git a/src/libraries/System.Linq/src/System/Linq/AppendPrepend.SpeedOpt.cs b/src/libraries/System.Linq/src/System/Linq/AppendPrepend.SpeedOpt.cs
index 01adb0af01e..cd6fb6fa171 100644
--- a/src/libraries/System.Linq/src/System/Linq/AppendPrepend.SpeedOpt.cs
+++ b/src/libraries/System.Linq/src/System/Linq/AppendPrepend.SpeedOpt.cs
@@ -127,7 +127,7 @@ public override int GetCount(bool onlyIfCheap)
                     return count == -1 ? -1 : count + 1;
                 }
 
-                return !onlyIfCheap || _source is ICollection<TSource> ? _source.Count() + 1 : -1;
+                return !onlyIfCheap || _source is IReadOnlyCollection<TSource> ? _source.Count() + 1 : -1;
             }
 
             public override TSource? TryGetFirst(out bool found)
@@ -276,7 +276,7 @@ public override int GetCount(bool onlyIfCheap)
                     return count == -1 ? -1 : count + _appendCount + _prependCount;
                 }
 
-                return !onlyIfCheap || _source is ICollection<TSource> ? _source.Count() + _appendCount + _prependCount : -1;
+                return !onlyIfCheap || _source is IReadOnlyCollection<TSource> ? _source.Count() + _appendCount + _prependCount : -1;
             }
         }
     }
diff --git a/src/libraries/System.Linq/src/System/Linq/Count.cs b/src/libraries/System.Linq/src/System/Linq/Count.cs
index 6b8819f8c3c..9b2511e0563 100644
--- a/src/libraries/System.Linq/src/System/Linq/Count.cs
+++ b/src/libraries/System.Linq/src/System/Linq/Count.cs
@@ -15,7 +15,7 @@ public static int Count<TSource>(this IEnumerable<TSource> source)
                 ThrowHelper.ThrowArgumentNullException(ExceptionArgument.source);
             }
 
-            if (source is ICollection<TSource> collectionoft)
+            if (source is IReadOnlyCollection<TSource> collectionoft)
             {
                 return collectionoft.Count;
             }
@@ -101,7 +101,7 @@ public static bool TryGetNonEnumeratedCount<TSource>(this IEnumerable<TSource> s
                 ThrowHelper.ThrowArgumentNullException(ExceptionArgument.source);
             }
 
-            if (source is ICollection<TSource> collectionoft)
+            if (source is IReadOnlyCollection<TSource> collectionoft)
             {
                 count = collectionoft.Count;
                 return true;
diff --git a/src/libraries/System.Linq/src/System/Linq/DefaultIfEmpty.SpeedOpt.cs b/src/libraries/System.Linq/src/System/Linq/DefaultIfEmpty.SpeedOpt.cs
index c89d6797581..45f673f7348 100644
--- a/src/libraries/System.Linq/src/System/Linq/DefaultIfEmpty.SpeedOpt.cs
+++ b/src/libraries/System.Linq/src/System/Linq/DefaultIfEmpty.SpeedOpt.cs
@@ -30,7 +30,7 @@ public override List<TSource> ToList()
             public override int GetCount(bool onlyIfCheap)
             {
                 int count;
-                if (!onlyIfCheap || _source is ICollection<TSource> || _source is ICollection)
+                if (!onlyIfCheap || _source is IReadOnlyCollection<TSource> || _source is ICollection)
                 {
                     count = _source.Count();
                 }
diff --git a/src/libraries/System.Linq/src/System/Linq/ElementAt.cs b/src/libraries/System.Linq/src/System/Linq/ElementAt.cs
index 97b87f9eba9..824a152a776 100644
--- a/src/libraries/System.Linq/src/System/Linq/ElementAt.cs
+++ b/src/libraries/System.Linq/src/System/Linq/ElementAt.cs
@@ -16,7 +16,7 @@ public static TSource ElementAt<TSource>(this IEnumerable<TSource> source, int i
                 ThrowHelper.ThrowArgumentNullException(ExceptionArgument.source);
             }
 
-            if (source is IList<TSource> list)
+            if (source is IReadOnlyList<TSource> list)
             {
                 return list[index];
             }
@@ -115,7 +115,7 @@ public static TSource ElementAt<TSource>(this IEnumerable<TSource> source, Index
 
         private static TSource? TryGetElementAt<TSource>(this IEnumerable<TSource> source, int index, out bool found)
         {
-            if (source is IList<TSource> list)
+            if (source is IReadOnlyList<TSource> list)
             {
                 return (found = (uint)index < (uint)list.Count) ?
                     list[index] :
diff --git a/src/libraries/System.Linq/src/System/Linq/First.cs b/src/libraries/System.Linq/src/System/Linq/First.cs
index 74ff81c2fec..22532cdb18d 100644
--- a/src/libraries/System.Linq/src/System/Linq/First.cs
+++ b/src/libraries/System.Linq/src/System/Linq/First.cs
@@ -78,7 +78,7 @@ public static TSource FirstOrDefault<TSource>(this IEnumerable<TSource> source,
 
         private static TSource? TryGetFirstNonIterator<TSource>(IEnumerable<TSource> source, out bool found)
         {
-            if (source is IList<TSource> list)
+            if (source is IReadOnlyList<TSource> list)
             {
                 if (list.Count > 0)
                 {
diff --git a/src/libraries/System.Linq/src/System/Linq/Grouping.cs b/src/libraries/System.Linq/src/System/Linq/Grouping.cs
index 6e19e4ab384..47be36572ac 100644
--- a/src/libraries/System.Linq/src/System/Linq/Grouping.cs
+++ b/src/libraries/System.Linq/src/System/Linq/Grouping.cs
@@ -351,7 +351,7 @@ public interface IGrouping<out TKey, out TElement> : IEnumerable<TElement>
 
     [DebuggerDisplay("Key = {Key}")]
     [DebuggerTypeProxy(typeof(SystemLinq_GroupingDebugView<,>))]
-    internal sealed class Grouping<TKey, TElement> : IGrouping<TKey, TElement>, IList<TElement>
+    internal sealed class Grouping<TKey, TElement> : IGrouping<TKey, TElement>, IList<TElement>, IReadOnlyList<TElement>
     {
         internal readonly TKey _key;
         internal readonly int _hashCode;
@@ -398,6 +398,8 @@ public IEnumerator<TElement> GetEnumerator()
 
         int ICollection<TElement>.Count => _count;
 
+        int IReadOnlyCollection<TElement>.Count => _count;
+
         bool ICollection<TElement>.IsReadOnly => true;
 
         void ICollection<TElement>.Add(TElement item) => ThrowHelper.ThrowNotSupportedException();
@@ -431,5 +433,18 @@ TElement IList<TElement>.this[int index]
 
             set => ThrowHelper.ThrowNotSupportedException();
         }
+
+        TElement IReadOnlyList<TElement>.this[int index]
+        {
+            get
+            {
+                if ((uint)index >= (uint)_count)
+                {
+                    ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
+                }
+
+                return _elements[index];
+            }
+        }
     }
 }
diff --git a/src/libraries/System.Linq/src/System/Linq/Last.cs b/src/libraries/System.Linq/src/System/Linq/Last.cs
index 007ee1659c3..e17e409e25e 100644
--- a/src/libraries/System.Linq/src/System/Linq/Last.cs
+++ b/src/libraries/System.Linq/src/System/Linq/Last.cs
@@ -77,7 +77,7 @@ public static TSource LastOrDefault<TSource>(this IEnumerable<TSource> source, F
 
         private static TSource? TryGetLastNonIterator<TSource>(IEnumerable<TSource> source, out bool found)
         {
-            if (source is IList<TSource> list)
+            if (source is IReadOnlyList<TSource> list)
             {
                 int count = list.Count;
                 if (count > 0)
@@ -126,7 +126,7 @@ public static TSource LastOrDefault<TSource>(this IEnumerable<TSource> source, F
                 return ordered.TryGetLast(predicate, out found);
             }
 
-            if (source is IList<TSource> list)
+            if (source is IReadOnlyList<TSource> list)
             {
                 for (int i = list.Count - 1; i >= 0; --i)
                 {
diff --git a/src/libraries/System.Linq/src/System/Linq/OrderedEnumerable.SpeedOpt.cs b/src/libraries/System.Linq/src/System/Linq/OrderedEnumerable.SpeedOpt.cs
index bf65a34b06e..ac9225303b4 100644
--- a/src/libraries/System.Linq/src/System/Linq/OrderedEnumerable.SpeedOpt.cs
+++ b/src/libraries/System.Linq/src/System/Linq/OrderedEnumerable.SpeedOpt.cs
@@ -58,7 +58,7 @@ public override int GetCount(bool onlyIfCheap)
                     return iterator.GetCount(onlyIfCheap);
                 }
 
-                return !onlyIfCheap || _source is ICollection<TElement> || _source is ICollection ? _source.Count() : -1;
+                return !onlyIfCheap || _source is IReadOnlyCollection<TElement> || _source is ICollection ? _source.Count() : -1;
             }
 
             internal TElement[] ToArray(int minIdx, int maxIdx)
diff --git a/src/libraries/System.Linq/src/System/Linq/Reverse.SpeedOpt.cs b/src/libraries/System.Linq/src/System/Linq/Reverse.SpeedOpt.cs
index d1ec26de879..168ca818c96 100644
--- a/src/libraries/System.Linq/src/System/Linq/Reverse.SpeedOpt.cs
+++ b/src/libraries/System.Linq/src/System/Linq/Reverse.SpeedOpt.cs
@@ -30,7 +30,7 @@ public override int GetCount(bool onlyIfCheap) =>
 
             public override TSource? TryGetElementAt(int index, out bool found)
             {
-                if (_source is IList<TSource> list)
+                if (_source is IReadOnlyList<TSource> list)
                 {
                     int count = list.Count;
                     if ((uint)index < (uint)count)
@@ -59,7 +59,7 @@ public override int GetCount(bool onlyIfCheap) =>
                 {
                     return iterator.TryGetLast(out found);
                 }
-                else if (_source is IList<TSource> list)
+                else if (_source is IReadOnlyList<TSource> list)
                 {
                     int count = list.Count;
                     if (count > 0)
@@ -95,7 +95,7 @@ public override int GetCount(bool onlyIfCheap) =>
                 {
                     return iterator.TryGetFirst(out found);
                 }
-                else if (_source is IList<TSource> list)
+                else if (_source is IReadOnlyList<TSource> list)
                 {
                     if (list.Count > 0)
                     {
diff --git a/src/libraries/System.Linq/src/System/Linq/SequenceEqual.cs b/src/libraries/System.Linq/src/System/Linq/SequenceEqual.cs
index 16bf60e6861..2568721f1ce 100644
--- a/src/libraries/System.Linq/src/System/Linq/SequenceEqual.cs
+++ b/src/libraries/System.Linq/src/System/Linq/SequenceEqual.cs
@@ -22,7 +22,7 @@ public static bool SequenceEqual<TSource>(this IEnumerable<TSource> first, IEnum
                 ThrowHelper.ThrowArgumentNullException(ExceptionArgument.second);
             }
 
-            if (first is ICollection<TSource> firstCol && second is ICollection<TSource> secondCol)
+            if (first is IReadOnlyCollection<TSource> firstCol && second is IReadOnlyCollection<TSource> secondCol)
             {
                 if (first.TryGetSpan(out ReadOnlySpan<TSource> firstSpan) && second.TryGetSpan(out ReadOnlySpan<TSource> secondSpan))
                 {
@@ -34,7 +34,7 @@ public static bool SequenceEqual<TSource>(this IEnumerable<TSource> first, IEnum
                     return false;
                 }
 
-                if (firstCol is IList<TSource> firstList && secondCol is IList<TSource> secondList)
+                if (firstCol is IReadOnlyList<TSource> firstList && secondCol is IReadOnlyList<TSource> secondList)
                 {
                     comparer ??= EqualityComparer<TSource>.Default;
 
diff --git a/src/libraries/System.Linq/src/System/Linq/Single.cs b/src/libraries/System.Linq/src/System/Linq/Single.cs
index 9c7328cc3ff..78e548e6806 100644
--- a/src/libraries/System.Linq/src/System/Linq/Single.cs
+++ b/src/libraries/System.Linq/src/System/Linq/Single.cs
@@ -69,7 +69,7 @@ public static TSource SingleOrDefault<TSource>(this IEnumerable<TSource> source,
                 ThrowHelper.ThrowArgumentNullException(ExceptionArgument.source);
             }
 
-            if (source is IList<TSource> list)
+            if (source is IReadOnlyList<TSource> list)
             {
                 switch (list.Count)
                 {
diff --git a/src/libraries/System.Net.Security/src/System/Security/Authentication/ExtendedProtection/ServiceNameCollection.cs b/src/libraries/System.Net.Security/src/System/Security/Authentication/ExtendedProtection/ServiceNameCollection.cs
index 532f6e950d6..4abe5887391 100644
--- a/src/libraries/System.Net.Security/src/System/Security/Authentication/ExtendedProtection/ServiceNameCollection.cs
+++ b/src/libraries/System.Net.Security/src/System/Security/Authentication/ExtendedProtection/ServiceNameCollection.cs
@@ -147,7 +147,7 @@ private void AddIfNew(string serviceName)
         /// </summary>
         private static int GetCountOrOne(IEnumerable collection)
         {
-            ICollection<string>? c = collection as ICollection<string>;
+            IReadOnlyCollection<string>? c = collection as IReadOnlyCollection<string>;
             return c != null ? c.Count : 1;
         }
 
diff --git a/src/libraries/System.Private.CoreLib/src/System/Collections/Concurrent/ConcurrentQueue.cs b/src/libraries/System.Private.CoreLib/src/System/Collections/Concurrent/ConcurrentQueue.cs
index bfa9fcf6546..2eff1c59b12 100644
--- a/src/libraries/System.Private.CoreLib/src/System/Collections/Concurrent/ConcurrentQueue.cs
+++ b/src/libraries/System.Private.CoreLib/src/System/Collections/Concurrent/ConcurrentQueue.cs
@@ -89,7 +89,7 @@ public ConcurrentQueue(IEnumerable<T> collection)
             // case we round its length up to a power of 2, as all segments must
             // be a power of 2 in length.
             int length = InitialSegmentLength;
-            if (collection is ICollection<T> c)
+            if (collection is IReadOnlyCollection<T> c)
             {
                 int count = c.Count;
                 if (count > length)
diff --git a/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/Dictionary.cs b/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/Dictionary.cs
index 9b18d4a125e..f20e3c5cfee 100644
--- a/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/Dictionary.cs
+++ b/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/Dictionary.cs
@@ -98,7 +98,7 @@ public Dictionary(IDictionary<TKey, TValue> dictionary, IEqualityComparer<TKey>?
         public Dictionary(IEnumerable<KeyValuePair<TKey, TValue>> collection) : this(collection, null) { }
 
         public Dictionary(IEnumerable<KeyValuePair<TKey, TValue>> collection, IEqualityComparer<TKey>? comparer) :
-            this((collection as ICollection<KeyValuePair<TKey, TValue>>)?.Count ?? 0, comparer)
+            this((collection as IReadOnlyCollection<KeyValuePair<TKey, TValue>>)?.Count ?? 0, comparer)
         {
             if (collection == null)
             {
diff --git a/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/HashSet.cs b/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/HashSet.cs
index 3b86548d20a..6467164d6be 100644
--- a/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/HashSet.cs
+++ b/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/HashSet.cs
@@ -99,7 +99,7 @@ public HashSet(IEnumerable<T> collection, IEqualityComparer<T>? comparer) : this
             {
                 // To avoid excess resizes, first set size based on collection's count. The collection may
                 // contain duplicates, so call TrimExcess if resulting HashSet is larger than the threshold.
-                if (collection is ICollection<T> coll)
+                if (collection is IReadOnlyCollection<T> coll)
                 {
                     int count = coll.Count;
                     if (count > 0)
@@ -513,7 +513,7 @@ public void IntersectWith(IEnumerable<T> other)
             }
 
             // If other is known to be empty, intersection is empty set; remove all elements, and we're done.
-            if (other is ICollection<T> otherAsCollection)
+            if (other is IReadOnlyCollection<T> otherAsCollection)
             {
                 if (otherAsCollection.Count == 0)
                 {
@@ -652,7 +652,7 @@ public bool IsProperSubsetOf(IEnumerable<T> other)
                 return false;
             }
 
-            if (other is ICollection<T> otherAsCollection)
+            if (other is IReadOnlyCollection<T> otherAsCollection)
             {
                 // No set is a proper subset of an empty set.
                 if (otherAsCollection.Count == 0)
@@ -701,7 +701,7 @@ public bool IsSupersetOf(IEnumerable<T> other)
             }
 
             // Try to fall out early based on counts.
-            if (other is ICollection<T> otherAsCollection)
+            if (other is IReadOnlyCollection<T> otherAsCollection)
             {
                 // If other is the empty set then this is a superset.
                 if (otherAsCollection.Count == 0)
@@ -745,7 +745,7 @@ public bool IsProperSupersetOf(IEnumerable<T> other)
                 return false;
             }
 
-            if (other is ICollection<T> otherAsCollection)
+            if (other is IReadOnlyCollection<T> otherAsCollection)
             {
                 // If other is the empty set then this is a superset.
                 if (otherAsCollection.Count == 0)
@@ -838,7 +838,7 @@ public bool SetEquals(IEnumerable<T> other)
             {
                 // If this count is 0 but other contains at least one element, they can't be equal.
                 if (Count == 0 &&
-                    other is ICollection<T> otherAsCollection &&
+                    other is IReadOnlyCollection<T> otherAsCollection &&
                     otherAsCollection.Count > 0)
                 {
                     return false;
diff --git a/src/libraries/System.Private.Xml/src/System/Xml/Xsl/Runtime/XmlQuerySequence.cs b/src/libraries/System.Private.Xml/src/System/Xml/Xsl/Runtime/XmlQuerySequence.cs
index 3c7e5b6ad25..23fc7a5c2e6 100644
--- a/src/libraries/System.Private.Xml/src/System/Xml/Xsl/Runtime/XmlQuerySequence.cs
+++ b/src/libraries/System.Private.Xml/src/System/Xml/Xsl/Runtime/XmlQuerySequence.cs
@@ -19,7 +19,7 @@ namespace System.Xml.Xsl.Runtime
     /// A sequence of Xml values that dynamically expands and allows random access to items.
     /// </summary>
     [EditorBrowsable(EditorBrowsableState.Never)]
-    public class XmlQuerySequence<T> : IList<T>, System.Collections.IList
+    public class XmlQuerySequence<T> : IList<T>, IReadOnlyList<T>, System.Collections.IList
     {
         public static readonly XmlQuerySequence<T> Empty = new XmlQuerySequence<T>();
 
@@ -489,7 +489,7 @@ public void AddClone(XPathItem item)
     /// A sequence of Xml nodes that dynamically expands and allows random access to items.
     /// </summary>
     [EditorBrowsable(EditorBrowsableState.Never)]
-    public sealed class XmlQueryNodeSequence : XmlQuerySequence<XPathNavigator>, IList<XPathItem>
+    public sealed class XmlQueryNodeSequence : XmlQuerySequence<XPathNavigator>, IList<XPathItem>, IReadOnlyList<XPathItem>
     {
         public static new readonly XmlQueryNodeSequence Empty = new XmlQueryNodeSequence();
 
@@ -731,6 +731,19 @@ XPathItem IList<XPathItem>.this[int index]
             set { throw new NotSupportedException(); }
         }
 
+        /// <summary>
+        /// Return item at the specified index.
+        /// </summary>
+        XPathItem IReadOnlyList<XPathItem>.this[int index]
+        {
+            get
+            {
+                ArgumentOutOfRangeException.ThrowIfGreaterThanOrEqual(index, Count);
+
+                return base[index];
+            }
+        }
+
         /// <summary>
         /// Returns the index of the specified value in the sequence.
         /// </summary>
diff --git a/src/libraries/System.Text.Json/src/System/Text/Json/Nodes/JsonObject.cs b/src/libraries/System.Text.Json/src/System/Text/Json/Nodes/JsonObject.cs
index 24f8653053a..021a4ac75b3 100644
--- a/src/libraries/System.Text.Json/src/System/Text/Json/Nodes/JsonObject.cs
+++ b/src/libraries/System.Text.Json/src/System/Text/Json/Nodes/JsonObject.cs
@@ -35,7 +35,12 @@ public JsonObject(IEnumerable<KeyValuePair<string, JsonNode?>> properties, JsonN
         {
             bool isCaseInsensitive = IsCaseInsensitive(options);
 
-            JsonPropertyDictionary<JsonNode?> dictionary = properties is ICollection<KeyValuePair<string, JsonNode?>> propertiesCollection
+            JsonPropertyDictionary<JsonNode?> dictionary =
+#if NET9_0_OR_GREATER // ICollection<T> : IReadOnlyCollection<T> on .NET 9+
+                properties is IReadOnlyCollection<KeyValuePair<string, JsonNode?>> propertiesCollection
+#else
+                properties is ICollection<KeyValuePair<string, JsonNode?>> propertiesCollection
+#endif
                 ? new(isCaseInsensitive, propertiesCollection.Count)
                 : new(isCaseInsensitive);
 
--
